# generate codons
RNA_nuc <- c("A", "C", "G", "U")
codons <- expand.grid(rep(list(RNA_nuc), 3), stringsAsFactors = FALSE)
codons <- do.call(paste0, as.list(codons[, 3:1]))

# amino acids
genetic_code <- c("K", "N", "K", "N", "T", "T", "T", "T", "R", "S", "R", "S", "I", "I", "M", "I", "Q", "H", "Q", "H", "P", "P", "P", "P", "R", "R", "R", "R", "L", "L", "L", "L", "E", "D", "E", "D", "A", "A", "A", "A", "G", "G", "G", "G", "V", "V", "V", "V", "*", "Y", "*", "Y", "S", "S", "S", "S", "*", "C", "W", "C", "L", "F", "L", "F") 
names(genetic_code) <- codons

# amino acid masses
amino_acids <- c("G", "A", "S", "P", "V", "T", "C", "I", "L", "N", "D", "K", "Q", "E", "M", "H", "F", "R", "Y", "W")
amino_acid_mass <- c(57, 71, 87, 97, 99, 101, 103, 113, 113, 114, 115, 128, 128, 129, 131, 137, 147, 156, 163, 186)
names(amino_acid_mass) <- amino_acids

#' Translate an RNA codon into an amino acid string
#' 
#' \code{TranslateCodon} converts an RNA codon into the corresponding amino acid specified by the genetic code. It is used to implement \code{\link{TranslateRNA}}.
#' 
#' @param codon An RNA codon, i.e. a 3 character string consisting only of the RNA nucleotides A, C, G, or U.
#' @return A single character giving the 1-letter code of the amino acid corresponding to \code{codon}.
#' @examples
#' TranslateCodon("AUG")
#' TranslateCodon("UAA")
#' TranslateCodon("UAG")
#' TranslateCodon("UGA")
TranslateCodon <- function(codon){
	translated_codon <- genetic_code[codon]
	names(translated_codon) <- NULL
	return(translated_codon)
}

#' Translate an RNA string into an amino acid string
#' 
#' \code{TranslateRNA} converts an RNA string into the corresponding peptide string specified by the genetic code.
#' 
#' @param RNA An RNA string, i.e. a string consisting only of the RNA nucleotides A, C, G, or U. \code{nchar(RNA)} should be a multiple of 3 so that it can be read as codons.
#' @param vector A logical scalar. Should the peptide string be split character by character into a character vector?
#' @return A single character giving the 1-letter code of the amino acid corresponding to \code{codon}.
#' @examples
#' RNA <- c("AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA")
#' TranslateRNA(RNA)
#' TranslateRNA(RNA, vector = TRUE)
TranslateRNA <- function(RNA, vector = FALSE){
	codons <- substring(RNA, seq(1, nchar(RNA), 3), seq(3, nchar(RNA), 3))
	peptide <- TranslateCodon(codons)
	n <- length(peptide)

	# check for stop codon
	if (identical("*", peptide[n])) {
		peptide <- peptide[1:(n - 1)]
	}

	if (!vector) {
		peptide <- paste(peptide, sep = "", collapse = "")
	}
	return(peptide)
}

#' Transcribe a DNA string into an RNA string
#' 
#' \code{TranscribeDNA} converts a DNA string into the corresponding RNA string as generated by DNA transcription. Essentially, this corresponds to changing all the T nucleotides in \code{DNA} to U ribonucleotides.
#' 
#' @param DNA An DNA string, i.e. a string consisting only of the DNA nucleotides A, C, G, or T.
#' @return An RNA string, i.e. a string consisting only of the RNA nucleotides A, C, G, or U.
#' @examples
#' TranscribeDNA("GTGAAACTTTTTCCTTGGTTTAATCAATAT")
TranscribeDNA <- function(DNA){
	RNA <- gsub("T", "U", DNA, fixed = TRUE)
	return(RNA)
}

#' Find substrings of a genome encoding a given amino acid sequence
#' 
#' \code{FindPeptide} searches \code{DNA} to find all substrings that encodes the amino acid string \code{peptide}. A substring \code{pattern} of \code{DNA} encodes \code{peptide} if the RNA string transcribed (see \code{\link{TranscribeDNA}}) from either \code{DNA} or \code{\link{ReverseComplement}(DNA)} translates into \code{peptide} (see \code{\link{TranslateRNA}}.
#' 
#' @inheritParams TranscribeDNA
#' @param peptide An amino acid string, i.e. a string consisting only of letters and excluding B, J, O, U, X, and Z.
#' @return All substrings of \code{DNA} encoding \code{peptide} (if any such substrings exist). 
#' @examples
#' DNA <- c("ATGGCCATGGCCCCCAGAACTGAGATCAATAGTACCCGTATTAACGGGTGA")
FindPeptide(DNA, "MA")
FindPeptide <- function(DNA, peptide){
	mRNA_length <- 3 * nchar(peptide)
	encoding_sequences <- character(2 * nchar(DNA))

	for (i in 1:(nchar(DNA) - mRNA_length + 1)) {
		reading_frame <- substring(DNA, i, i + mRNA_length - 1)
		mRNA <- TranscribeDNA(reading_frame)
		pep <- TranslateRNA(mRNA)

		rev_mRNA <- TranscribeDNA(ReverseComplement(reading_frame))
		rev_pep <- TranslateRNA(rev_mRNA)

		if (identical(pep, peptide) || identical(rev_pep, peptide)) {
			encoding_sequences[i] <- reading_frame
		}
	}

	encoding_sequences <- encoding_sequences[nchar(encoding_sequences) != 0]
	return(encoding_sequences)
}

#' Find the mass of the prefix of a peptide string
#' 
#' \code{PrefixMass} finds the mass of the first \code{i} amino acids in an amino acid string \code{peptide} (i.e. a peptide). If a value for \code{i} is not provided \code{PrefixMass} instead returns the vector containing the masses for all the prefixes of \code{peptide} starting from the null prefix with mass 0 and ending with the entirety of \code{peptide}.
#' 
#' @inheritParams peptide
#' @param i An integer specifying that the prefix consists of the first \code{i} amino acids in \code{peptide}. If a value for \code{i} is not provided then a vector is returned containing the masses for all the prefixes of \code{peptide}.
#' @return The combined mass in daltons of the first \code{i} amino acids of \code{peptide}.
#' @examples
#' peptide <- "NQEL"
#' PrefixMass(peptide, 0)
#' PrefixMass(peptide, 1)
#' PrefixMass(peptide, 4)
#' PrefixMass(peptide)
PrefixMass <- function(peptide, i = NULL){
	# empty prefix
	if (identical(i, 0L)) {
		return(0)
	}

	prefix_mass <- numeric(0)

	# check for returning all prefixes
	if (is.null(i)) {
		for (j in 0:nchar(peptide)) {
			prefix_mass <- c(prefix_mass, PrefixMass(peptide, j))
		}
	} else {
		prefix <- substring(peptide, 1:i, 1:i)
		prefix_mass <- sum(amino_acid_mass[prefix])
	}
	return(prefix_mass)
}

#' Generate the theoretical spectrum of a peptide
#' 
#' \code{PeptideSpectrum} generates the theoretical spectrum of the linear or cyclic amino acid string \code{peptide}. The theoretical spectrum of a peptide is the collection of all of the masses of its subpeptides, in addition to the mass 0 and the mass of the entire peptide. The theoretical spectrum can contain duplicate elements, as in the case for "NQEL", where "NQ" and "EL" have the same mass. The peptide can be either linear or cyclic, specified by the logical scalar \code{cyclic}. If the peptide is cyclic the cyclospectrum is generated, which assumes that subpeptides can wrap around the ends of \code{peptide}.
#' 
#' @inheritParams FindPeptide
#' @param cyclic A logical scalar. Is the peptide cyclic? The default value for \code{cyclic} is \code{TRUE}.
#' @return A numerical vector containing the theoretical spectrum for \code{peptide} in daltons.
#' @examples
#' peptide <- "LEQN"
#' PeptideSpectrum(peptide)
PeptideSpectrum <- function(peptide, cyclic = TRUE){
	peptide_mass <- PrefixMass(peptide, nchar(peptide))
	peptide_spectrum <- 0L

	for (i in 0:(nchar(peptide) - 1)) {
		for (j in (i + 1):nchar(peptide)) {
			pep <- PrefixMass(peptide, j) - PrefixMass(peptide, i)
			peptide_spectrum <- c(peptide_spectrum, pep)
			if (i > 0 && j < nchar(peptide) && cyclic) {
				pep <- peptide_mass - pep
				peptide_spectrum <- c(peptide_spectrum, pep)
			}
		}
	}
	return(sort(peptide_spectrum))
}
