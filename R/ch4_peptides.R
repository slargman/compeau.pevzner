# generate codons
RNA_nuc <- c("A", "C", "G", "U")
codons <- expand.grid(rep(list(RNA_nuc), 3), stringsAsFactors = FALSE)
codons <- do.call(paste0, as.list(codons[, 3:1]))

# amino acids
genetic_code <- c("K", "N", "K", "N", "T", "T", "T", "T", "R", "S", "R", "S", "I", "I", "M", "I", "Q", "H", "Q", "H", "P", "P", "P", "P", "R", "R", "R", "R", "L", "L", "L", "L", "E", "D", "E", "D", "A", "A", "A", "A", "G", "G", "G", "G", "V", "V", "V", "V", "*", "Y", "*", "Y", "S", "S", "S", "S", "*", "C", "W", "C", "L", "F", "L", "F") 
names(genetic_code) <- codons

# amino acid masses
amino_acids <- c("G", "A", "S", "P", "V", "T", "C", "I", "L", "N", "D", "K", "Q", "E", "M", "H", "F", "R", "Y", "W")
amino_acid_mass <- c(57, 71, 87, 97, 99, 101, 103, 113, 113, 114, 115, 128, 128, 129, 131, 137, 147, 156, 163, 186)
names(amino_acid_mass) <- amino_acids

#' Translate an RNA codon into an amino acid string
#' 
#' \code{TranslateCodon} converts an RNA codon into the corresponding amino acid specified by the genetic code. It is used to implement \code{\link{TranslateRNA}}.
#' 
#' @param codon An RNA codon, i.e. a 3 character string consisting only of the RNA nucleotides A, C, G, or U.
#' @return A single character giving the 1-letter code of the amino acid corresponding to \code{codon}.
#' @examples
#' TranslateCodon("AUG")
#' TranslateCodon("UAA")
#' TranslateCodon("UAG")
#' TranslateCodon("UGA")
TranslateCodon <- function(codon){
	translated_codon <- genetic_code[codon]
	names(translated_codon) <- NULL
	return(translated_codon)
}

#' Translate an RNA string into an amino acid string
#' 
#' \code{TranslateRNA} converts an RNA string into the corresponding peptide string specified by the genetic code.
#' 
#' @param RNA An RNA string, i.e. a string consisting only of the RNA nucleotides A, C, G, or U. \code{nchar(RNA)} should be a multiple of 3 so that it can be read as codons.
#' @param vector A logical scalar. Should the peptide string be split character by character into a character vector?
#' @return A single character giving the 1-letter code of the amino acid corresponding to \code{codon}.
#' @examples
#' RNA <- c("AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA")
#' TranslateRNA(RNA)
#' TranslateRNA(RNA, vector = TRUE)
TranslateRNA <- function(RNA, vector = FALSE){
	codons <- substring(RNA, seq(1, nchar(RNA), 3), seq(3, nchar(RNA), 3))
	peptide <- TranslateCodon(codons)
	n <- length(peptide)

	# check for stop codon
	if (identical("*", peptide[n])) {
		peptide <- peptide[1:(n - 1)]
	}

	if (!vector) {
		peptide <- paste(peptide, sep = "", collapse = "")
	}
	return(peptide)
}

#' Transcribe a DNA string into an RNA string
#' 
#' \code{TranscribeDNA} converts a DNA string into the corresponding RNA string as generated by DNA transcription. Essentially, this corresponds to changing all the T nucleotides in \code{DNA} to U ribonucleotides.
#' 
#' @param DNA An DNA string, i.e. a string consisting only of the DNA nucleotides A, C, G, or T.
#' @return An RNA string, i.e. a string consisting only of the RNA nucleotides A, C, G, or U.
#' @examples
#' TranscribeDNA("GTGAAACTTTTTCCTTGGTTTAATCAATAT")
TranscribeDNA <- function(DNA){
	RNA <- gsub("T", "U", DNA, fixed = TRUE)
	return(RNA)
}

#' Find substrings of a genome encoding a given amino acid sequence
#' 
#' \code{FindPeptide} searches \code{DNA} to find all substrings that encodes the amino acid string \code{peptide}. A substring \code{pattern} of \code{DNA} encodes \code{peptide} if the RNA string transcribed (see \code{\link{TranscribeDNA}}) from either \code{DNA} or \code{\link{ReverseComplement}(DNA)} translates into \code{peptide} (see \code{\link{TranslateRNA}}.
#' 
#' @inheritParams TranscribeDNA
#' @param peptide An amino acid string, i.e. a string consisting only of letters and excluding B, J, O, U, X, and Z.
#' @return All substrings of \code{DNA} encoding \code{peptide} (if any such substrings exist). 
#' @examples
#' DNA <- c("ATGGCCATGGCCCCCAGAACTGAGATCAATAGTACCCGTATTAACGGGTGA")
#' FindPeptide(DNA, "MA")
FindPeptide <- function(DNA, peptide){
	mRNA_length <- 3 * nchar(peptide)
	encoding_sequences <- character(2 * nchar(DNA))

	for (i in 1:(nchar(DNA) - mRNA_length + 1)) {
		reading_frame <- substring(DNA, i, i + mRNA_length - 1)
		mRNA <- TranscribeDNA(reading_frame)
		pep <- TranslateRNA(mRNA)

		rev_mRNA <- TranscribeDNA(ReverseComplement(reading_frame))
		rev_pep <- TranslateRNA(rev_mRNA)

		if (identical(pep, peptide) || identical(rev_pep, peptide)) {
			encoding_sequences[i] <- reading_frame
		}
	}

	encoding_sequences <- encoding_sequences[nchar(encoding_sequences) != 0]
	return(encoding_sequences)
}

#' Find the mass of the prefix of a peptide string
#' 
#' \code{PrefixMass} finds the mass of the first \code{i} amino acids in an amino acid string \code{peptide} (i.e. a peptide). If a value for \code{i} is not provided \code{PrefixMass} instead returns the vector containing the masses for all the prefixes of \code{peptide} starting from the null prefix with mass 0 and ending with the entirety of \code{peptide}.
#' 
#' @inheritParams peptide
#' @param i An integer specifying that the prefix consists of the first \code{i} amino acids in \code{peptide}. If a value for \code{i} is not provided then a vector is returned containing the masses for all the prefixes of \code{peptide}.
#' @param use.mass A logical scalar. Are the peptides represented by their masses instead of single letter amino acid codes?
#' @return The combined mass in daltons of the first \code{i} amino acids of \code{peptide}.
#' @examples
#' peptide <- "NQEL"
#' PrefixMass(peptide, 0)
#' PrefixMass(peptide, 1)
#' PrefixMass(peptide, 4)
#' PrefixMass(peptide)
PrefixMass <- function(peptide, i = NULL, use.mass = FALSE){
	# empty prefix
	if (isTRUE(i == 0)) {
		return(0)
	}

	# split by character
	if (use.mass) {
		mass <- peptide
	} else {
		mass <- amino_acid_mass[strsplit(peptide, split = "")[[1]]]
	}
	prefix_mass <- numeric(0)

	# check for returning all prefixes
	if (is.null(i)) {
		for (j in 0:length(mass)) {
			prefix_mass <- c(prefix_mass, PrefixMass(mass, j, use.mass = TRUE))
		}
	} else {
		prefix_mass <- sum(mass[1:i])
	}
	return(prefix_mass)
}

#' Generate the theoretical spectrum of a peptide
#' 
#' \code{PeptideSpectrum} generates the theoretical spectrum of the linear or cyclic amino acid string \code{peptide}. The theoretical spectrum of a peptide is the collection of all of the masses of its subpeptides, in addition to the mass 0 and the mass of the entire peptide. The theoretical spectrum can contain duplicate elements, as in the case for "NQEL", where "NQ" and "EL" have the same mass. The peptide can be either linear or cyclic, specified by the logical scalar \code{cyclic}. If the peptide is cyclic the cyclospectrum is generated, which assumes that subpeptides can wrap around the ends of \code{peptide}.
#' 
#' @inheritParams FindPeptide
#' @param cyclic A logical scalar. Is the peptide cyclic? The default value for \code{cyclic} is \code{TRUE}.
#' @return A numerical vector containing the theoretical spectrum for \code{peptide} in daltons.
#' @examples
#' peptide <- "LEQN"
#' PeptideSpectrum(peptide)
PeptideSpectrum <- function(peptide, cyclic = TRUE){
	peptide_mass <- PrefixMass(peptide, nchar(peptide))
	peptide_spectrum <- 0L

	for (i in 0:(nchar(peptide) - 1)) {
		for (j in (i + 1):nchar(peptide)) {
			pep <- PrefixMass(peptide, j) - PrefixMass(peptide, i)
			peptide_spectrum <- c(peptide_spectrum, pep)
			if (i > 0 && j < nchar(peptide) && cyclic) {
				pep <- peptide_mass - pep
				peptide_spectrum <- c(peptide_spectrum, pep)
			}
		}
	}
	return(sort(peptide_spectrum))
}

#' Find the mass of a peptide
#' 
#' \code{PeptideMass} find the mass of the amino acid string \code{peptide} in daltons.
#' 
#' @inheritParams FindPeptide
#' @return The mass in daltons of the amino acid string \code{peptide}.
#' @examples
#' PeptideMass("A")
#' PeptideMass("NQEL")
PeptideMass <- function(peptide){
	n <- nchar(peptide)
	amino_acids <- substring(peptide, 1:n, 1:n)
	mass <- sum(amino_acid_mass[amino_acids])
	return(mass)
}

#' Compute the number of peptides of given total mass
#' 
#' @param mass An integer denoting a mass in daltons.
#' @return The number of linear peptides having integer mass \code{mass}.
#' @examples
#' CountPeptidesWithMass(1024)
CountPeptidesWithMass <- function(mass){
}

#' Determine whether a peptide is consistent with a spectrum
#' 
#' \code{CheckSpectrumConsistency} determines whether the linear peptide \code{peptide} is consistent with the experimental spectrum \code{spectrum}. A linear peptide is consistent with \code{spectrum} if every mass in its theoretical spectrum (see \code{\link{PeptideSpectrum}}) is contained in \code{spectrum}. If a mass appears more than once in the theoretical spectrum of the linear peptide, then it must appear at least as many times in \code{spectrum} in order for the linear peptide to be consistent with \code{spectrum}.
#' 
#' @inheritParams FindPeptide
#' @param spectrum A numerical vector containing a collection of (possibly repeated) integers corresponding to an ideal experimental spectrum. An ideal spectrum is one which coincides with the peptide's theoretical spectrum, e.g. as generated by \code{\link{PeptideSpectrum}}.
#' @return A logical scalar equal to \code{TRUE} if \code{peptide} is consistent with \code{spectrum} and \code{FALSE} otherwise.
#' @examples
#' tyrocidine_B1 <- "VKLFPWFNQY"
#' spectrum <- PeptideSpectrum(tyrocidine_B1)
#' CheckSpectrumConsistency("VKF", spectrum)
#' CheckSpectrumConsistency("VKY", spectrum)
CheckSpectrumConsistency <- function(peptide, spectrum){
	pep_spectrum <- PeptideSpectrum(peptide, cyclic = F)
	for (mass in pep_spectrum) {
		i_pep <- sum(pep_spectrum == mass)
		i_spec <- sum(spectrum == mass)
		if (i_pep > i_spec) {
			return(FALSE)
		}
		pep_spectrum <- pep_spectrum[pep_spectrum != mass]
	}
	return(TRUE)
}

#' Find a peptide with a given spectrum
#' 
#' \code{CyclopeptideSequencing} finds a cyclic peptide with theoretical spectrum matching the ideal spectrum \code{spectrum}.
#' 
#' @inheritParams CheckSpectrumConsistency
#' @return A character vector containing every amino acid string \code{peptide} such that \code{\link{PeptideSpectrum}(peptide)} is equivalent to \code{spectrum} (if such a string exists).
#' @examples
#' spectrum <- c(0, 113, 128, 186, 241, 299, 314, 427)
#' CyclopeptideSequencing(spectrum)
CyclopeptideSequencing <- function(spectrum){
	peptides <- ""
	parent_mass <- max(spectrum)
	matching_peptides <- character(0)
	while (length(peptides) > 0) {
		# expand peptides
		peptides <- as.vector(sapply(peptides, function(x) paste0(x, amino_acids)))
		# check for match or inconsistency
		for (peptide in peptides) {
			if (PeptideMass(peptide) == parent_mass) {
				if (identical(PeptideSpectrum(peptide), spectrum)) {
					matching_peptides <- c(matching_peptides, peptide)
				}
			} else if (!CheckSpectrumConsistency(peptide, spectrum)) {
				peptides <- peptides[peptides != peptide]
			}
		}
	}
	return(matching_peptides)
}

#' Represent a peptide by its amino acid masses
#' 
#' \code{PrintCyclopeptideSequencing} replaces the 20 character long alphabet of single letter amino acid codes with the 18 integer long alphabet of amino acid masses. \code{PrintCyclopeptideSequencing} formats its output in the proper manner for input into Rosalind. 
#' 
#' @param peptides A character vector consisting of amino acid strings, i.e. strings consisting only of letters and excluding B, J, O, U, X, and Z.
#' @return A character vector consisting of the peptides in \code{peptides} coded by the masses of their constituent amino acids, with each mass separated by "-".
#' @examples
#' spectrum <- c(0, 113, 128, 186, 241, 299, 314, 427)
#' peptides <- CyclopeptideSequencing(spectrum)
#' PrintCyclopeptideSequencing(peptides)
PrintCyclopeptideSequencing <- function(peptides){
	peptides_num <- lapply(as.list(peptides), function(x) amino_acid_mass[substring(x, 1:nchar(x), 1:nchar(x))])
	peptides_num <- sapply(peptides_num, function(x) paste(x, sep = "", collapse = "-"))
	return(unique(peptides_num))
}

#' Compute the score of a peptide against a spectrum
#' 
#' In order to handle the sequencing of a peptide using noisy spectra, \code{PeptideScore} computes the score of a peptide against a spectrum. Given a cyclic or linear peptide \code{peptide} and a spectrum \code{spectrum}, the score of \code{peptide} against \code{spectrum} is defined as the number of masses shared between \code{\link{PeptideSpectrum}(peptide)} and \code{spectrum}. \code{PeptideScore} takes into account the multiplicities of shared masses, i.e. how many times each mass occurs in each spectrum.
#' 
#' @inheritParams FindPeptide
#' @inheritParams CheckSpectrumConsistency
#' @inheritParams PeptideSpectrum
#' @return The score of \code{peptide} against \code{spectrum}.
#' @examples
#' peptide <- "NQEL"
#' spectrum <- c(0, 99, 113, 114, 128, 227, 257, 299, 355, 356, 370, 371, 484)
#' PeptideScore(peptide, spectrum)
#' PeptideScore(peptide, spectrum, cyclic = FALSE)
PeptideScore <- function(peptide, spectrum, cyclic = TRUE){
	pep_spectrum <- PeptideSpectrum(peptide, cyclic = cyclic)
	score <- 0

	for (mass in pep_spectrum){
		num_mass_pep <- sum(pep_spectrum == mass)
		num_mass_spec <- sum(spectrum == mass)
		score_mass <- min(num_mass_pep, num_mass_spec)
		score <- score + score_mass
		pep_spectrum <- pep_spectrum[pep_spectrum != mass]
	}

	return(score)
}

#' Trim a leaderboard of peptides for sequencing
#' 
#' \code{TrimLeadeboard} trims a leaderboard of peptides generated in \code{\link{LeaderboardCyclopeptideSequencing}}. \code{TrimLeadeboard} sorts all the peptides in \code{leaderboard} according to their scores with respect to \code{spectrum} (see \code{link{PeptideScore}}) then retains the top \code{N} peptides in \code{leaderboard}, removing the rest. Note that the \code{\link{PeptideScore}} scores the peptides in \code{leaderboards} as linear peptides.
#' 
#' @inheritParams CheckSpectrumConsistency
#' @param leaderboard A leaderboard of linear peptides, i.e. a character vector containing amino acid strings.
#' @param N An integer specifying how many peptides, including ties, should be retained. Due to ties, more than \code{N} peptides might actually be retained.
#' @return The top \code{N} peptides from \code{leaderboard} scored against \code{spectrum}.
#' @examples
#' leaderboard <- c("LAST", "ALST", "TLLT", "TQAS")
#' spectrum <- c(0, 71, 87, 101, 113, 158, 184, 188, 259, 271, 372)
#' N <- 2
#' TrimLeaderboard(leaderboard, spectrum, 2)
TrimLeaderboard <- function(leaderboard, spectrum, N){
	linear_scores <- sapply(as.list(leaderboard), function(x) PeptideScore(x, spectrum, cyclic = F))
	leaders <- tibble(pep = leaderboard, score = linear_scores)
	leaders <- leaders[order(linear_scores, decreasing = T), ]
	cutoff <- leaders$score[N]
	trimmed_leaderboard <- as.vector(leaders$pep[leaders$score >= cutoff])
	return(trimmed_leaderboard)
}

#' Determine a peptide sequence from a noisy experimental spectrum
#' 
#' @inheritParams CheckSpectrumConsistency
#' @inheritParams TrimLeaderboard
#' @return
#' @examples
#' N <- 10
#' spectrum <- c(0, 71, 113, 129, 147, 200, 218, 260, 313, 331, 347, 389, 460)
#' leader <- LeaderboardCyclopeptideSequencing(spectrum, N)
#' PrintCyclopeptideSequencing(leader)
LeaderboardCyclopeptideSequencing <- function(spectrum, N){
	leaderboard <- ""
	leader_peptide <- ""
	leader_score <- PeptideScore(leader_peptide, spectrum)
	parent_mass <- max(spectrum)

	while (length(leaderboard) > 0) {
		# expand leaderboard
		leaderboard <- as.vector(sapply(leaderboard, function(x) paste0(x, amino_acids)))

		# check for new leader or inconsistency
		for (peptide in leaderboard) {
			if (PeptideMass(peptide) == parent_mass) {
				score <- PeptideScore(peptide, spectrum, cyclic = F)

				# update leader
				if (score > leader_score) {
					leader_peptide <- peptide
					leader_score <- score
				}
			} else if (PeptideMass(peptide) > parent_mass) {
				leaderboard <- leaderboard[leaderboard != peptide]
			}
		}

		leaderboard <- TrimLeaderboard(leaderboard, spectrum, N)
	}
	return(leader_peptide)
}

#' Generate the convolution of a spectrum
#' 
#' \code{SpectrumConvolution} generates the convolution of a peptide spectrum (see \code{\link{PeptideSpectrum}}) in order to generate an alphabet of amino acids to be used in determining a peptide from a noisy spectrum. The convolution of a spectrum is defined as the positive differences of masses in the spectrum. The most frequently appearing integers in the convolution ranging from 57 to 200 can be used as the amino acid alphabet for sequencing a peptide.
#' 
#' @inheritParams CheckSpectrumConsistency
#' @return A numeric vector containing all the positive differences of masses in \code{spectrum} listed in decreasing order of their multiplicities.
#' @examples
#' spectrum <- c(0, 137, 186, 323)
#' SpectrumConvolution(spectrum)
#' spectrum <- PeptideSpectrum("NQEL")
#' SpectrumConvolution(spectrum)
SpectrumConvolution <- function(spectrum){
	convolution <- unlist(sapply(seq_along(spectrum), function(i) abs(spectrum[-(1:i)] - spectrum[i])))
	convolution <- convolution[convolution != 0]
	convolution <- sort(convolution)
	multiplicity <- unlist(sapply(convolution, function(x) sum(convolution == x))) 
	convolution <- convolution[order(multiplicity, decreasing = T)]
	return(convolution)
}
