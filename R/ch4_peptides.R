# generate codons
RNA_nuc <- c("A", "C", "G", "U")
codons <- expand.grid(rep(list(RNA_nuc), 3), stringsAsFactors = FALSE)
codons <- do.call(paste0, as.list(codons[, 3:1]))

# amino acids
genetic_code <- c("K", "N", "K", "N", "T", "T", "T", "T", "R", "S", "R", "S", "I", "I", "M", "I", "Q", "H", "Q", "H", "P", "P", "P", "P", "R", "R", "R", "R", "L", "L", "L", "L", "E", "D", "E", "D", "A", "A", "A", "A", "G", "G", "G", "G", "V", "V", "V", "V", "*", "Y", "*", "Y", "S", "S", "S", "S", "*", "C", "W", "C", "L", "F", "L", "F") 
names(genetic_code) <- codons

# amino acid masses
amino_acids <- c("G", "A", "S", "P", "V", "T", "C", "I", "L", "N", "D", "K", "Q", "E", "M", "H", "F", "R", "Y", "W")
amino_acid_mass <- c(57, 71, 87, 97, 99, 101, 103, 113, 113, 114, 115, 128, 128, 129, 131, 137, 147, 156, 163, 186)
names(amino_acid_mass) <- amino_acids

#' Translate an RNA codon into an amino acid string
#' 
#' \code{TranslateCodon} converts an RNA codon into the corresponding amino acid specified by the genetic code. It is used to implement \code{\link{TranslateRNA}}.
#' 
#' @param codon An RNA codon, i.e. a 3 character string consisting only of the RNA nucleotides A, C, G, or U.
#' @return A single character giving the 1-letter code of the amino acid corresponding to \code{codon}.
#' @examples
#' TranslateCodon("AUG")
#' TranslateCodon("UAA")
#' TranslateCodon("UAG")
#' TranslateCodon("UGA")
TranslateCodon <- function(codon){
	translated_codon <- genetic_code[codon]
	names(translated_codon) <- NULL
	return(translated_codon)
}

#' Translate an RNA string into an amino acid string
#' 
#' \code{TranslateRNA} converts an RNA string into the corresponding peptide string specified by the genetic code.
#' 
#' @param RNA An RNA string, i.e. a string consisting only of the RNA nucleotides A, C, G, or U. \code{nchar(RNA)} should be a multiple of 3 so that it can be read as codons.
#' @param vector A logical scalar. Should the peptide string be split character by character into a character vector?
#' @return A single character giving the 1-letter code of the amino acid corresponding to \code{codon}.
#' @examples
#' RNA <- c("AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA")
#' TranslateRNA(RNA)
#' TranslateRNA(RNA, vector = TRUE)
TranslateRNA <- function(RNA, vector = FALSE){
	codons <- substring(RNA, seq(1, nchar(RNA), 3), seq(3, nchar(RNA), 3))
	peptide <- TranslateCodon(codons)
	n <- length(peptide)

	# check for stop codon
	if (identical("*", peptide[n])) {
		peptide <- peptide[1:(n - 1)]
	}

	if (!vector) {
		peptide <- paste(peptide, sep = "", collapse = "")
	}
	return(peptide)
}

#' Transcribe a DNA string into an RNA string
#' 
#' \code{TranscribeDNA} converts a DNA string into the corresponding RNA string as generated by DNA transcription. Essentially, this corresponds to changing all the T nucleotides in \code{DNA} to U ribonucleotides.
#' 
#' @param DNA An DNA string, i.e. a string consisting only of the DNA nucleotides A, C, G, or T.
#' @return An RNA string, i.e. a string consisting only of the RNA nucleotides A, C, G, or U.
#' @examples
#' TranscribeDNA("GTGAAACTTTTTCCTTGGTTTAATCAATAT")
TranscribeDNA <- function(DNA){
	RNA <- gsub("T", "U", DNA, fixed = TRUE)
	return(RNA)
}

#' Find substrings of a genome encoding a given amino acid sequence
#' 
#' \code{FindPeptide} searches \code{DNA} to find all substrings that encodes the amino acid string \code{peptide}. A substring \code{pattern} of \code{DNA} encodes \code{peptide} if the RNA string transcribed (see \code{\link{TranscribeDNA}}) from either \code{DNA} or \code{\link{ReverseComplement}(DNA)} translates into \code{peptide} (see \code{\link{TranslateRNA}}.
#' 
#' @inheritParams TranscribeDNA
#' @param peptide An amino acid string, i.e. a string consisting only of letters and excluding B, J, O, U, X, and Z.
#' @return All substrings of \code{DNA} encoding \code{peptide} (if any such substrings exist). 
#' @examples
#' DNA <- c("ATGGCCATGGCCCCCAGAACTGAGATCAATAGTACCCGTATTAACGGGTGA")
#' FindPeptide(DNA, "MA")
FindPeptide <- function(DNA, peptide){
	mRNA_length <- 3 * nchar(peptide)
	encoding_sequences <- character(2 * nchar(DNA))

	for (i in 1:(nchar(DNA) - mRNA_length + 1)) {
		reading_frame <- substring(DNA, i, i + mRNA_length - 1)
		mRNA <- TranscribeDNA(reading_frame)
		pep <- TranslateRNA(mRNA)

		rev_mRNA <- TranscribeDNA(ReverseComplement(reading_frame))
		rev_pep <- TranslateRNA(rev_mRNA)

		if (identical(pep, peptide) || identical(rev_pep, peptide)) {
			encoding_sequences[i] <- reading_frame
		}
	}

	encoding_sequences <- encoding_sequences[nchar(encoding_sequences) != 0]
	return(encoding_sequences)
}

#' Represent a peptide by the masses of its amino acids
#'
#' \code{RepresentPeptideByMass} represents a peptide \code{peptide} by the mass (in Daltons) of its amino acids rather than the single letter amino acid code. This allows for an extended alphabet for use in peptide sequencing, in particular non-proteinogenic amino acids of arbitrary mass.
#' 
#' @param peptide A character vector of peptides. The elements of the vector are peptides which can be represented by a string of one letter codes (i.e. all letters excluding B, J, O, U, X, and Z) or the corresponding masses of the amino acids separated by "-".
#' @return A character vector consisting of the masses of the constituent amino acids of \code{peptide} separated by "-"
#' @examples
#' peptide <- "NQEL"
#' pep_mass <- RepresentPeptideByMass(peptide)
#' RepresentPeptideByMass(pep_mass)
RepresentPeptideByMass <- function(peptide){
	codes <- grepl("[[:upper:]]", peptide)
	numbers <- grepl("[[:digit:]]", pep_mass)

	if (!all(codes | numbers)) {
		stop("peptide consist of letter codes or masses")
	}

	peptide[codes] <- vapply(peptide[codes], function(x) paste(amino_acid_mass[strsplit(x, split = "")[[1]]], sep = "", collapse = "-"), character(sum(codes)))

	return(peptide)
}

#' Convert a peptide string to a numeric vector of masses
#' 
#' \code{ConvertPeptideToNumeric} converts a peptide represented by a string of single letter codes or masses of the corresponding amino acids into a numeric vector of the amino acid masses.
#' 
#' @inheritParams RepresentPeptideByMass
#' @return A numeric vector containing the masses of the constituent amino acids of \code{peptide}
#' @examples
#' peptide <- "NQEL"
#' pep_mass <- RepresentPeptideByMass(peptide)
#' ConvertPeptideToNumeric(peptide)
#' ConvertPeptideToNumeric(pep_mass)
ConvertPeptideToNumeric <- function(peptide){
	if (is.numeric(peptide)) {
		return(peptide)
	} else if (length(peptide) > 1) {
		stop("peptide must have length 1")
	}
	pep <- RepresentPeptideByMass(peptide)
	pep <- unlist(strsplit(pep, split = "-", fixed = FALSE))
	pep <- as.numeric(pep)
	return(pep)
}

#' Find the mass of the prefix of a peptide string
#' 
#' \code{PrefixMass} finds the mass of the first \code{i} amino acids in an amino acid string \code{peptide} (i.e. a peptide). If a value for \code{i} is not provided \code{PrefixMass} instead returns the vector containing the masses for all the prefixes of \code{peptide} starting from the null prefix with mass 0 and ending with the entirety of \code{peptide}.
#' 
#' @inheritParams peptide
#' @param i An integer specifying that the prefix consists of the first \code{i} amino acids in \code{peptide}. If a value for \code{i} is not provided then a vector is returned containing the masses for all the prefixes of \code{peptide}.
#' @param use.mass A logical scalar. Are the peptides represented by their masses instead of single letter amino acid codes?
#' @return The combined mass in daltons of the first \code{i} amino acids of \code{peptide}.
#' @examples
#' peptide <- "NQEL"
#' PrefixMass(peptide, 0)
#' PrefixMass(peptide, 1)
#' PrefixMass(peptide, 4)
#' PrefixMass(peptide)
PrefixMass <- function(peptide, i = NULL){
	# empty prefix
	if (isTRUE(i == 0)) {
		return(0)
	}

	pep <- ConvertPeptideToNumeric(peptide)
	prefix_mass <- numeric(0)

	# check for returning all prefixes
	if (is.null(i)) {
		for (j in 0:length(pep)) {
			prefix_mass <- c(prefix_mass, PrefixMass(peptide, j))
		}
	} else {
		prefix_mass <- sum(pep[1:i])
	}
	return(prefix_mass)
}

#' Find the mass of a peptide
#' 
#' \code{PeptideMass} find the mass of the amino acid string \code{peptide} in daltons.
#' 
#' @inheritParams FindPeptide
#' @return The mass in daltons of the amino acid string \code{peptide}.
#' @examples
#' PeptideMass("A")
#' PeptideMass("NQEL")
#' pep <- ConvertPeptideToNumeric("NQEL")
#' PeptideMass(pep)
PeptideMass <- function(peptide){
	pep_mass <- sum(ConvertPeptideToNumeric(peptide))
	return(pep_mass)
}

#' Generate the theoretical spectrum of a peptide
#' 
#' \code{PeptideSpectrum} generates the theoretical spectrum of the linear or cyclic amino acid string \code{peptide}. The theoretical spectrum of a peptide is the collection of all of the masses of its subpeptides, in addition to the mass 0 and the mass of the entire peptide. The theoretical spectrum can contain duplicate elements, as in the case for "NQEL", where "NQ" and "EL" have the same mass. The peptide can be either linear or cyclic, specified by the logical scalar \code{cyclic}. If the peptide is cyclic the cyclospectrum is generated, which assumes that subpeptides can wrap around the ends of \code{peptide}.
#' 
#' @inheritParams FindPeptide
#' @inheritParams PrefixMass
#' @param cyclic A logical scalar. Is the peptide cyclic? The default value for \code{cyclic} is \code{TRUE}.
#' @return A numerical vector containing the theoretical spectrum for \code{peptide} in daltons.
#' @examples
#' peptide <- "LEQN"
#' PeptideSpectrum(peptide)
#' peptide <- RepresentPeptideByMass("LEQN")
#' PeptideSpectrum(peptide)
PeptideSpectrum <- function(peptide, cyclic = TRUE){
	pep <- ConvertPeptideToNumeric(peptide)
	peptide_mass <- PeptideMass(pep)
	peptide_spectrum <- 0L

	for (i in 0:(length(pep) - 1)) {
		for (j in (i + 1):length(pep)) {
			pep_mass <- PrefixMass(pep, j) - PrefixMass(pep, i)
			peptide_spectrum <- c(peptide_spectrum, pep_mass)
			if (i > 0 && j < length(pep) && cyclic) {
				pep_mass <- peptide_mass - pep_mass
				peptide_spectrum <- c(peptide_spectrum, pep_mass)
			}
		}
	}
	return(sort(peptide_spectrum))
}

#' Compute the number of peptides of given total mass
#' 
#' @param mass An integer denoting a mass in daltons.
#' @return The number of linear peptides having integer mass \code{mass}.
#' @examples
#' CountPeptidesWithMass(1024)
CountPeptidesWithMass <- function(mass){
}

#' Determine whether a peptide is consistent with a spectrum
#' 
#' \code{CheckSpectrumConsistency} determines whether the linear peptide \code{peptide} is consistent with the experimental spectrum \code{spectrum}. A linear peptide is consistent with \code{spectrum} if every mass in its theoretical spectrum (see \code{\link{PeptideSpectrum}}) is contained in \code{spectrum}. If a mass appears more than once in the theoretical spectrum of the linear peptide, then it must appear at least as many times in \code{spectrum} in order for the linear peptide to be consistent with \code{spectrum}.
#' 
#' @inheritParams FindPeptide
#' @param spectrum A numerical vector containing a collection of (possibly repeated) integers corresponding to an ideal experimental spectrum. An ideal spectrum is one which coincides with the peptide's theoretical spectrum, e.g. as generated by \code{\link{PeptideSpectrum}}.
#' @return A logical scalar equal to \code{TRUE} if \code{peptide} is consistent with \code{spectrum} and \code{FALSE} otherwise.
#' @examples
#' tyrocidine_B1 <- "VKLFPWFNQY"
#' spectrum <- PeptideSpectrum(tyrocidine_B1)
#' CheckSpectrumConsistency("VKF", spectrum)
#' CheckSpectrumConsistency(RepresentPeptideByMass("VKF"), spectrum)
#' CheckSpectrumConsistency("VKY", spectrum)
#' CheckSpectrumConsistency(RepresentPeptideByMass("VKY"), spectrum)
#' CheckSpectrumConsistency("VKL", spectrum)
#' CheckSpectrumConsistency(RepresentPeptideByMass("VKL"), spectrum)
CheckSpectrumConsistency <- function(peptide, spectrum){
	pep_spectrum <- PeptideSpectrum(peptide, cyclic = F)
	for (mass in pep_spectrum) {
		i_pep <- sum(pep_spectrum == mass)
		i_spec <- sum(spectrum == mass)
		if (i_pep > i_spec) {
			return(FALSE)
		}
		pep_spectrum <- pep_spectrum[pep_spectrum != mass]
	}
	return(TRUE)
}

#' Find a peptide with a given spectrum
#' 
#' \code{CyclopeptideSequencing} finds a cyclic peptide with theoretical spectrum matching the ideal spectrum \code{spectrum}.
#' 
#' @inheritParams CheckSpectrumConsistency
#' @return A character vector containing every amino acid string \code{peptide} such that \code{\link{PeptideSpectrum}(peptide)} is equivalent to \code{spectrum} (if such a string exists).
#' @examples
#' spectrum <- c(0, 113, 128, 186, 241, 299, 314, 427)
#' CyclopeptideSequencing(spectrum)
CyclopeptideSequencing <- function(spectrum, alphabet = unique(amino_acid_mass)){
	peptides <- ""
	parent_mass <- max(spectrum)
	matching_peptides <- character(0)
	sep <- ""
	while (length(peptides) > 0) {
		# expand peptides
		peptides <- as.vector(vapply(peptides, function(x) paste(x, alphabet, sep = sep), character(length(alphabet))))
		sep <- "-"
		# check for match or inconsistency
		for (peptide in peptides) {
			if (PeptideMass(peptide) == parent_mass) {
				if (identical(PeptideSpectrum(peptide), spectrum)) {
					matching_peptides <- c(matching_peptides, peptide)
				}
			} else if (!CheckSpectrumConsistency(peptide, spectrum)) {
				peptides <- peptides[peptides != peptide]
			}
		}
	}
	return(matching_peptides)
}

#' Compute the score of a peptide against a spectrum
#' 
#' In order to handle the sequencing of a peptide using noisy spectra, \code{PeptideScore} computes the score of a peptide against a spectrum. Given a cyclic or linear peptide \code{peptide} and a spectrum \code{spectrum}, the score of \code{peptide} against \code{spectrum} is defined as the number of masses shared between \code{\link{PeptideSpectrum}(peptide)} and \code{spectrum}. \code{PeptideScore} takes into account the multiplicities of shared masses, i.e. how many times each mass occurs in each spectrum.
#' 
#' @inheritParams FindPeptide
#' @inheritParams CheckSpectrumConsistency
#' @inheritParams PeptideSpectrum
#' @return The score of \code{peptide} against \code{spectrum}.
#' @examples
#' peptide <- "NQEL"
#' spectrum <- c(0, 99, 113, 114, 128, 227, 257, 299, 355, 356, 370, 371, 484)
#' PeptideScore(peptide, spectrum)
#' PeptideScore(peptide, spectrum, cyclic = FALSE)
PeptideScore <- function(peptide, spectrum, cyclic = TRUE){
	pep_spectrum <- PeptideSpectrum(peptide, cyclic = cyclic)
	score <- 0

	for (mass in pep_spectrum){
		num_mass_pep <- sum(pep_spectrum == mass)
		num_mass_spec <- sum(spectrum == mass)
		score_mass <- min(num_mass_pep, num_mass_spec)
		score <- score + score_mass
		pep_spectrum <- pep_spectrum[pep_spectrum != mass]
	}

	return(score)
}

#' Trim a leaderboard of peptides for sequencing
#' 
#' \code{TrimLeadeboard} trims a leaderboard of peptides generated in \code{\link{LeaderboardCyclopeptideSequencing}}. \code{TrimLeadeboard} sorts all the peptides in \code{leaderboard} according to their scores with respect to \code{spectrum} (see \code{link{PeptideScore}}) then retains the top \code{N} peptides in \code{leaderboard}, removing the rest. Note that the \code{\link{PeptideScore}} scores the peptides in \code{leaderboards} as linear peptides.
#' 
#' @inheritParams CheckSpectrumConsistency
#' @param leaderboard A leaderboard of linear peptides, i.e. a character vector containing amino acid strings.
#' @param N An integer specifying how many peptides, including ties, should be retained. Due to ties, more than \code{N} peptides might actually be retained.
#' @return The top \code{N} peptides from \code{leaderboard} scored against \code{spectrum}.
#' @examples
#' leaderboard <- c("LAST", "ALST", "TLLT", "TQAS")
#' spectrum <- c(0, 71, 87, 101, 113, 158, 184, 188, 259, 271, 372)
#' N <- 2
#' TrimLeaderboard(leaderboard, spectrum, 2)
TrimLeaderboard <- function(leaderboard, spectrum, N){
	if (N > length(leaderboard)){
		return(leaderboard)
	}
	linear_scores <- sapply(leaderboard, function(x) PeptideScore(x, spectrum, cyclic = F))
	leaders <- tibble(pep = leaderboard, score = linear_scores)
	leaders <- leaders[order(linear_scores, decreasing = T), ]
	cutoff <- leaders$score[N]
	trimmed_leaderboard <- as.vector(leaders$pep[leaders$score >= cutoff])
	return(trimmed_leaderboard)
}

#' Determine a peptide sequence from a noisy experimental spectrum
#' 
#' @inheritParams CheckSpectrumConsistency
#' @inheritParams TrimLeaderboard
#' @return
#' @examples
#' N <- 10
#' spectrum <- c(0, 71, 113, 129, 147, 200, 218, 260, 313, 331, 347, 389, 460)
#' leader <- LeaderboardCyclopeptideSequencing(spectrum, N)
#' PrintCyclopeptideSequencing(leader)
LeaderboardCyclopeptideSequencing <- function(spectrum, N, alphabet = unique(amino_acid_mass)){
	leaderboard <- list(numeric(0))
	leader_peptide <- numeric(0)
	leader_score <- 0
	parent_mass <- max(spectrum)

	while (length(leaderboard) > 0) {
		# expand leaderboard
		leaderboard <- lapply(leaderboard, function(x) lapply(alphabet, function(y) c(x, y)))
		leaderboard <- unlist(leaderboard, recursive = FALSE)

		# check for new leader or inconsistency
		for (peptide in leaderboard) {
			if (PeptideMass(peptide) == parent_mass) {
				score <- PeptideScore(peptide, spectrum, cyclic = F)

				# update leader
				if (score > leader_score) {
					leader_peptide <- peptide
					leader_score <- score
				}
			} else if (PeptideMass(peptide) > parent_mass) {
				leaderboard <- leaderboard[!sapply(leaderboard, identical, peptide)]
			}
		}

		leaderboard <- TrimLeaderboard(leaderboard, spectrum, N)
	}
	return(leader_peptide)
}

#' Generate the convolution of a spectrum
#' 
#' \code{SpectrumConvolution} generates the convolution of a peptide spectrum (see \code{\link{PeptideSpectrum}}) in order to generate an alphabet of amino acids to be used in determining a peptide from a noisy spectrum. The convolution of a spectrum is defined as the positive differences of masses in the spectrum. The most frequently appearing integers in the convolution ranging from 57 to 200 can be used as the amino acid alphabet for sequencing a peptide.
#' 
#' @inheritParams CheckSpectrumConsistency
#' @return A numeric vector containing all the positive differences of masses in \code{spectrum} listed in decreasing order of their multiplicities.
#' @examples
#' spectrum <- c(0, 137, 186, 323)
#' SpectrumConvolution(spectrum)
#' spectrum <- PeptideSpectrum("NQEL")
#' SpectrumConvolution(spectrum)
SpectrumConvolution <- function(spectrum){
	convolution <- unlist(sapply(seq_along(spectrum), function(i) abs(spectrum[-(1:i)] - spectrum[i])))
	convolution <- convolution[convolution != 0]
	convolution <- sort(convolution)
	multiplicity <- unlist(sapply(convolution, function(x) sum(convolution == x))) 
	convolution <- convolution[order(multiplicity, decreasing = T)]
	return(convolution)
}

#' Determine a peptide sequence using non-proteinogenic amino acids
#' 
#' @inheritParams CheckSpectrumConsistency
#' @inheritParams TrimLeaderboard
#' @param M An integer determining how many amino acids should be used in the alphabet for constructing peptides. The top \code{M} amino acids (and ties) of the convolution of \code{spectrum} that fall between 57 and 200 are used in the alphabet. Due to ties there may be more than \code{M} amino acids in the alphabet.
#' @return A cyclic peptide \code{leader_peptide} with amino acids taken from the top \code{M} elements (and ties) of the convolution of \code{spectrum} that fall between 57 and 200, and where the size of the leaderboard is restricted to the top \code{N} (and ties).
#' @examples
#' M <- 20
#' N <- 60
#' spectrum <- c(57, 57, 71, 99, 129, 137, 170, 186, 194, 208, 228, 265, 285, 299, 307, 323, 356, 364, 394, 422, 493)
#' ConvolutionCyclopeptideSequencing(spectrum, M, N)
ConvolutionCyclopeptideSequencing <- function(spectrum, M, N){
	# generate amino acid alphabet
	convolution <- SpectrumConvolution(spectrum)
	# mass cutoffs
	convolution <- convolution[57 <= convolution & convolution <= 200]
	cutoff_amino_acid <- unique(convolution)[M]
	i_cutoff_amino_acid <- which(convolution == cutoff_amino_acid)[1]
	multiplicity <- unlist(sapply(convolution, function(x) sum(convolution == x))) 
	cutoff <- multiplicity[i_cutoff_amino_acid]
	alphabet <- unique(convolution[multiplicity >= cutoff])
	leader_peptide <- LeaderboardCyclopeptideSequencing(spectrum, N, alphabet)
	return(leader_peptide)
}
